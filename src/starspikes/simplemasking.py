import os
import sys
import logging
import argparse

import regions
from tqdm.auto import tqdm

import numpy as np

from astropy.coordinates import SkyCoord
from astropy import units
from astropy.table import Table
from astropy.wcs import WCS
from astropy.io import fits
from astropy.io.registry import IORegistryError

import matplotlib as mpl
from matplotlib import pyplot as plt

from starspikes.masking import distanceFromLine
from scipy.stats import linregress

def __argsHandler(options=None):
    parser = argparse.ArgumentParser(description='Process some integers.')

    parser.add_argument(
        'image', metavar='INPUT_IMG', type=str, nargs=1,
        help='The input image in fits format'
    )

    parser.add_argument(
        'input_catalog', metavar='INPUT_CAT', type=str, nargs=1,
        help='A catalog generated by sectractor using the same input image. '
        'Must contain the columns RA, DEC, MAG_AUTO, MU_MAX (or FLUX_MAX), '
        'and FWHM_IAMGE (of FWHM_WORLD).'
    )

    parser.add_argument(
        'angle', metavar='ANGLE', type=float,
        help='The angle of the primary spike.'
    )

    parser.add_argument(
        '--cat-hdu', metavar='CAT_HDU', type=int, default=1,
        help='The HDU containing the catalog to use (eg. for LDAC fits '
        'catalog generated by sextractor use %(metavar)s=2). If this argument '
        'is not specified, the image is loaded from the first HDU.'
    )

    parser.add_argument(
        '--image-hdu', metavar='IMAGE_HDU', type=int, default=1,
        help='The HDU containing the image. If this argument '
        'is not specified, the image is loaded from the first HDU.'
    )

    parser.add_argument(
        '--check-images', default=False, action='store_true',
        help='Generate control images for the various operations performed.'
    )

    parser.add_argument(
        '--check-dir', metavar='CHK_FOLDER', type=str, default='checkimgs',
        nargs=1, help='Set the directory where check images and files are '
        'written. %(metavar)s should be a relative or an absolute path, if the'
        ' folder does not exists it will be automatically created. '
        'If this argument is not provided, the default value '
        '%(metavar)s=%(default)s is used.'
    )

    parser.add_argument(
        '--out-dir', metavar='OUT_FOLDER', type=str, default='.',
        help='Set the output directory where cleaned catalog are saved. '
        'If not specified, the current working directory is used.'
    )
    parser.add_argument(
        '--check-dpi', metavar='DPI', type=int, default=150,
        help='Set the DPI of the control images. if this parameter is not '
        'specified then the default value %(metavar)s=%(default)d is used.'
    )

    parser.add_argument(
        '--dist-tol', metavar='DIST_TOL_ARCSEC', type=float, default=0,
        help='Set the max distance, in arcsc, between two objects to be '
        'considered the same. If it is not specified, this parameter will have'
        ' a default value of %(metavar)s=%(default)d.'
    )

    parser.add_argument(
        '--star-thresh', type=float, default=None,
        help='Threshold for star selection. The greater it is, the more '
        'objects are considered as stars.'
    )

    parser.add_argument(
        '--sel-sigma', type=float, default=5,
        help='Number of std. dev.s to select stars from the fitted sequence.'
    )

    parser.add_argument(
        '--magauto-thresh', metavar='MAG_AUTO_THRESH', type=int, default=50,
        nargs=1, help='Ignore objects with MAG_AUTO > %(metavar)s. If not '
        'specified, the deafult value %(metavar)s=%(default)d is used.'
    )

    parser.add_argument(
        '--magauto-key', metavar='MAGAUTO_KEY', type=str, default='MAG_AUTO',
        nargs=1, help='Set the name of the column containing the automatic '
        'magnitudes. For catalogs generated by sextractor '
        '%(metavar)s=MAG_AUTO. If this argument is not specified the default '
        'value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--mumax-key', metavar='MU_MAX_KEY', type=str, default='MU_MAX',
        help='Set the name of the column containing the peak surface '
        'brightness above background. For catalogs generated by sextractor '
        '%(metavar)s=MU_MAX. If this argument is not specified the default '
        'value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--fluxmax-key', metavar='FLUX_MAX_KEY', type=str, default='FLUX_MAX',
        help='Set the name of the column containing the peak flux. This is '
        'used as fallback only if MU_MAX is not present in the catalog. '
        'For catalogs generated by sextractor %(metavar)s=FLUX_MAX. If this '
        'argument is not specified the default value %(metavar)s=%(default)s '
        'is used'
    )

    parser.add_argument(
        '--fwhm-key', metavar='FWHM_KEY', type=str,
        default='FWHM_IMAGE', help='Set the name of the column '
        'containing the FWHM of the objects. For catalogs generated by '
        'Sextractor %(metavar)s=FWHM_IMAGE or %(metavar)s=FWHM_WORLD.'
        'If this argument is not specified the default value '
        '%(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--ra-key', metavar='RA_KEY', type=str, default='RA',
        help='Set the name of the column containing the ra'
        'coordinates of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--dec-key', metavar='DEC_KEY', type=str, default='DEC',
        help='Set the name of the column containing the dec'
        'coordinates of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--aimage-key', metavar='A_IMAGE_KEY', type=str, default='A_IMAGE',
        help='Set the name of the column containing the major axis'
        'of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--bimage-key', metavar='B_IMAGE_KEY', type=str, default='B_IMAGE',
        help='Set the name of the column containing the y pixel'
        'coordinates of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--thetaimage-key', metavar='THETA_IMAGE_KEY', type=str,
        default='THETA_IMAGE', nargs=1, help='Set the name of the column '
        'containing the rotation angle of the major axis of the objects relative'
        'to the first image axis. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--delta-mag', metavar='DELTA_MAG', type=float,
        default=2, help='Number of magnitudes above the saturation level.'
    )

    parser.add_argument(
        '--ellipticity-threshold', metavar='TRESHOLD', type=float, default=0.2,
        help='Sets the ellipticity threshold below which objects that are '
        'maked as spurios spike detections will be removed.'
    )

    parser.add_argument(
        '--n-spikes', '-n', metavar='N', type=int, default=4,
        help='Set the number of spikes a star has. The default value is .'
        '%(metavar)s=%(default)s'
    )

    parser.add_argument(
        '--mask-width', metavar='WIDTH_ARCSEC', type=int, default=0.35,
        help='Set the width of the mask around the spikes. If this parameter '
        'is not specified the default value %(metavar)s=%(default)s is used.'
    )

    parser.add_argument(
        '--verbose', '-v', default=False, action='store_true',
        help='Increase the information outputed by the program.'
    )

    parser.add_argument(
        '--debug', default=False, action='store_true',
        help='Increase further the information outputed by the program.'
    )

    parser.add_argument(
        '--mask-a', type=float, default=5,
        help='Ref. spike size in arcsec. '
        'The default value %(metavar)s=%(default)s'
    )

    parser.add_argument(
        '--mask-b', type=float, default=0.01,
        help='Mask spike pseudo-flux scale factor.'
        'The default value %(metavar)s=%(default)s'
    )

    parser.add_argument(
        '--mask-magref', type=float, default=25,
        help='Ref. magnitude for spike size.'
        'The default value %(metavar)s=%(default)s'
    )

    return parser.parse_args(options)

def select_stars_from_cat(
    in_cat, fwhm_key='FWHM_IMAGE', pixel_scale_arcsec=None,
    fwhm_in_pixels='auto', selection_thresh=None
):
    if fwhm_in_pixels == 'auto':
        if 'image' in fwhm_key.lower():
            fwhm_in_pixels = True
        else:
            fwhm_in_pixels = False

    if pixel_scale_arcsec is not None:
        if fwhm_in_pixels:
            valid_fwhm_mask = in_cat[fwhm_key] > 2
        else:
            valid_fwhm_mask = in_cat[fwhm_key] > (pixel_scale_arcsec / 1800)
    else:
        if fwhm_in_pixels:
            valid_fwhm_mask = in_cat[fwhm_key] > 2
        else:
            valid_fwhm_mask = in_cat[fwhm_key] > 0

    cat = in_cat[valid_fwhm_mask]
    fwhm_min = np.nanmin(cat[fwhm_key])

    if (selection_thresh is None) or (str(selection_thresh).lower() == 'auto'):
        fwhm_thresh = np.median(cat[cat[fwhm_key] < fwhm_min * 3][fwhm_key])
    else:
        fwhm_thresh = fwhm_min * (1 + selection_thresh)
    if pixel_scale_arcsec is None:
        logging.info(f"FWHM: {fwhm_min:.2f} pixel")
    else:
        logging.info(f"FWHM: {fwhm_min * pixel_scale_arcsec:.2f}\"")
    return cat[cat[fwhm_key] <= fwhm_thresh]


def fit_star_sequence(mag_auto, m_max):
    med_mag_auto = np.median(mag_auto)
    lreg = linregress(mag_auto, m_max)

    res = m_max - (lreg.intercept + lreg.slope * mag_auto)
    scatt = 1.4826 * np.median(np.abs(res - np.median(res)))

    pivot = (
        med_mag_auto,
        lreg.intercept + lreg.slope * med_mag_auto
    )

    return lreg, pivot, scatt


def get_star_selection_mask(
    mag_auto, m_max, min_m_max, lreg, scatt, sel_sigma=3, delta_mag =2
):
    mag_auto_sat_level = (min_m_max - lreg.intercept) / lreg.slope
    mumax_hi_thresh = min_m_max + sel_sigma * scatt

    brightest_mask1 = m_max <= (
                                    lreg.intercept +
                                    mag_auto * lreg.slope +
                                    sel_sigma * scatt
                                )
    max_mag_level = mag_auto_sat_level + delta_mag
    brightest_mask1 &= mag_auto <= max_mag_level
    brightest_mask2 = m_max <= mumax_hi_thresh

    selection_mask = brightest_mask1 | brightest_mask2
    return selection_mask, mag_auto_sat_level, mumax_hi_thresh

def generate_masks(
    star_coords, star_mags, angle, spike_width,
        n_spikes=4, a=5, b=0.01, mag_ref=25
):
    mask_list = []
    for center_sc, mag in zip(tqdm(star_coords), star_mags):
        len_spike = (
            a + b * (
                10**((mag_ref - mag)/2.5)
            )
        ) * units.arcsec


        for k in range(n_spikes):
            spike = regions.RectangleSkyRegion(
                center=center_sc,
                width=spike_width,
                height=len_spike,
                angle=(angle + (k * 360 / n_spikes) ) * units.deg
            )
            mask_list.append(spike)

        circle = regions.CircleSkyRegion(
            center=center_sc,
            radius=2*units.arcsec
        )

        mask_list.append(circle)
    return mask_list


def get_catalog_mask(coords, mask_list, img_wcs):
    cleanup_mask = None
    for region in tqdm(mask_list):
        if cleanup_mask is None:
            cleanup_mask = region.contains(coords, img_wcs)
        else:
            cleanup_mask |= region.contains(coords, img_wcs)
    return cleanup_mask


def make_stars_selection_plot(
        mag_auto, m_max, fwhm, lreg=None, x_label=None, y_label=None,
        z_label=None, ax=None, figsize=(8, 8), vmin=None, vmax=None
):
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=figsize)
        update = False
    else:
        update = True
        ax = ax
        fig = ax.figure

    ax.set_facecolor('#EAEAF2')
    ax.grid(
        visible=None, which='major', axis='both', color='white', alpha=1.0
    )
    ax.set_axisbelow(True)

    scatter = ax.scatter(
        mag_auto,
        m_max,
        s=10,
        c=fwhm,
        cmap='plasma',
        label='Candidate stars',
        vmin=vmin,
        vmax=vmax
    )

    if lreg is not None:
        pivot = (
            np.nanmean(mag_auto),
            np.nanmean(mag_auto) * lreg.slope + lreg.intercept
        )

        ax.axline(
            pivot,
            slope=lreg.slope,
            zorder=2,
            c='k',
            alpha=0.7,
            label='Fitted star sequence '
        )

    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)
    if not update:
        cbar = plt.colorbar(scatter)
        cbar.ax.set_ylabel(z_label)
    plt.tight_layout()

    return fig, ax


def make_bright_stars_selection_plot(
    mag_auto, m_max, fwhm,
    brightest_mag_auto, brightest_m_max,
    mag_auto_sat_level, mumax_hi_thresh,
    sel_sigma, scatt,
    lreg=None, pivot=None,
    idx_sorted=None,
    scatter_marker_size=5,
    sel_boundary_lw=1.5,
    x_label=None,
    y_label=None,
    cbar_label=None,
    ax=None,
    figsize=(8, 8),
    vmin=None,
    vmax=None
):
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=figsize)
        update = False
    else:
        update = True
        ax = ax
        fig = ax.figure

    ax.set_facecolor('#EAEAF2')
    ax.grid(
        visible=None, which='major', axis='both', color='white', alpha=1.0
    )
    ax.set_axisbelow(True)

    if idx_sorted is None:
        xx = mag_auto
        yy = m_max
        zz = fwhm
    else:
        xx = mag_auto[idx_sorted]
        yy = m_max[idx_sorted]
        zz = fwhm[idx_sorted]

    scatter = ax.scatter(
        xx, yy,
        c=zz,
        cmap='plasma',
        s=scatter_marker_size,
        alpha=1.0,
        label='Objects',
        vmin=vmin,
        vmax=vmax
    )

    _ = ax.scatter(
        brightest_mag_auto,
        brightest_m_max,
        facecolor='none',
        edgecolor='red',
        s=scatter_marker_size,
        lw=1.5,
        alpha=0.5,
        label='Selected objects'
    )

    plt.margins(0.05, 0.05)
    fit_lw = 1.5

    ax.set_xlabel(x_label)
    ax.set_ylabel(y_label)

    if not update:
        cbar = fig.colorbar(
            scatter,
            location='right',
            anchor=(0, 0.3)
        )

        cbar.ax.get_yaxis().labelpad = 15
        cbar.ax.set_ylabel(cbar_label, rotation=270)

        plt.tight_layout()

    x_min = ax.get_xlim()[0]
    x_max = ax.get_xlim()[1]
    y_min = ax.get_ylim()[0]

    # Plotting star sequence fit
    if lreg is not None:
        ax.axline(
            pivot,
            slope=lreg.slope,
            zorder=2,
            color='magenta',
            ls='-',
            lw=fit_lw,
            alpha=0.5,
            label='Fitted star sequence '
        )

    ax.axvline(
        mag_auto_sat_level,
        color='red',
        ls='--',
        lw=fit_lw,
        label=f'{x_label} sat. level',
        alpha=0.3
    )

    # Plot brightest and saturated objects selection region
    ax.plot(
        (x_min, mag_auto_sat_level, x_max),
        (
            mumax_hi_thresh,
            mumax_hi_thresh,
            lreg.intercept + x_max * lreg.slope + sel_sigma * scatt
        ),
        color='red',
        ls='--',
        lw=sel_boundary_lw
    )

    _ = ax.annotate(
        '$x_{sat}$',
        xy=(mag_auto_sat_level, 0),
        xytext=(mag_auto_sat_level, 0.025),
        xycoords=ax.get_xaxis_transform(),
        textcoords=ax.get_xaxis_transform(),
        fontsize=16,
        arrowprops=dict(
            facecolor='black',
            arrowstyle='-'
        )
    )

    _ = ax.legend()
    return fig, ax


def load_input_files(
    input_catalog_path, image_path, cat_hdu=0, image_hdu=0,
    magauto_key='MAG_AUTO', mumax_key='MU_MAX', fluxmax_key='FLUX_MAX',
    magauto_thresh=40
):
    logging.info(f"Loading input catalog {input_catalog_path}...")
    try:
        orig_cat = Table.read(input_catalog_path, cat_hdu - 1)
    except FileNotFoundError as exc:
        logging.error(f"Invalid catalog: {str(exc)}")
        sys.exit(1)
    except IORegistryError:
        try:
            orig_cat = Table.read(
                input_catalog_path,
                format='ascii',
                header_start=-1
            )
        except Exception as exc:
            logging.error(f"Invalid catalog: {str(exc)}")
            sys.exit(1)

    if magauto_key not in orig_cat.colnames:
        logging.error(f"Input catalog does not contain {magauto_key}")
        sys.exit(1)

    if (
            (mumax_key not in orig_cat.colnames) and
            (fluxmax_key not in orig_cat.colnames)
    ):
        logging.error(
            f"Input catalog does not contain neither {mumax_key} nor "
            f"{fluxmax_key}. At least one of the two is required!"
        )
        sys.exit(1)

    elif mumax_key in orig_cat.colnames:
        m_key = mumax_key
    else:
        m_key = fluxmax_key

    cat = orig_cat[orig_cat[magauto_key] < magauto_thresh]

    cat_magauto = cat[magauto_key]
    if m_key == mumax_key:
        cat_m_max = cat[m_key]
    else:
        cat_m_max = -2.5 * np.log10(cat[m_key])

    logging.info(f"Loading WCS from image {image_path}")
    img_header = fits.getheader(image_path, ext=image_hdu - 1)
    img_wcs = WCS(img_header)

    img_pixelscale = np.mean([
        x.to(units.arcsec).value for x in img_wcs.proj_plane_pixel_scales()
    ])
    logging.info(f"Mean pixel-scale: {img_pixelscale:.2f}\"")

    return (
        orig_cat, cat, cat_magauto, cat_m_max, img_wcs, img_pixelscale, m_key
    )

def main(options=None):
    args = __argsHandler(options)

    font = {
        'size': 12
    }
    mpl.rc('font', **font)

    args = __argsHandler(options)

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    console_handler = logging.StreamHandler()

    if args.verbose or args.debug:
        console_handler.setLevel(logging.INFO)
    else:
        console_handler.setLevel(logging.WARN)

    logger.addHandler(console_handler)

    cat_basename = os.path.basename(args.input_catalog[0])
    cat_basename = os.path.splitext(cat_basename)[0]

    if not os.path.isdir(args.check_dir):
        os.mkdir(args.check_dir)

    chk_img_out = os.path.join(
        args.check_dir,
        cat_basename
    )

    if not os.path.isdir(chk_img_out):
        os.mkdir(chk_img_out)

    (
        orig_cat,
        cat,
        cat_magauto,
        cat_m_max,
        img_wcs,
        img_pixelscale,
        m_key
    ) = load_input_files(
        input_catalog_path=args.input_catalog[0],
        image_path=args.image[0],
        cat_hdu=args.cat_hdu,
        image_hdu=args.image_hdu,
        magauto_key=args.magauto_key,
        mumax_key=args.mumax_key,
        fluxmax_key=args.fluxmax_key,
        magauto_thresh=args.magauto_thresh
    )

    only_stars = select_stars_from_cat(
        cat,
        fwhm_key=args.fwhm_key,
        pixel_scale_arcsec=img_pixelscale,
        selection_thresh=args.star_thresh
    )

    mag_auto = only_stars[args.magauto_key]

    if m_key == args.mumax_key:
        m_max = only_stars[m_key]
        _y_label = f"{m_key} [$mag \\cdot arcsec^{{-2}}$]"
    else:
        m_max = -2.5*np.log10(only_stars[m_key])
        _y_label = (f'$-2.5\\log(\\rm{{{m_key.replace('_', '\\_')}}})$ '
                    '[Arbitrary units]')

    lreg, pivot, scatt = fit_star_sequence(mag_auto, m_max)

    if args.check_images:
        fig, ax = make_stars_selection_plot(
            mag_auto, m_max, only_stars[args.fwhm_key],
            lreg=lreg,
            x_label=args.magauto_key,
            y_label=_y_label,
            z_label=args.fwhm_key
        )
        plt.tight_layout()

        fig.savefig(
            os.path.join(chk_img_out, "fwhm_selection.png"),
            dpi=args.check_dpi
        )
    plt.close(fig)

    # Selecting points that are approximately  in the linear region
    # of the star sequence

    res = get_star_selection_mask(
        mag_auto=cat[args.magauto_key],
        m_max=cat_m_max,
        min_m_max=np.nanmin(m_max),
        lreg=lreg,
        scatt=scatt,
        sel_sigma=args.sel_sigma,
        delta_mag=args.delta_mag
    )
    selection_mask, mag_auto_sat_level, mumax_hi_thresh = res

    brightest_objects = cat[selection_mask]

    # Making final plot
    if m_key == args.mumax_key:
        brightest_m_max = brightest_objects[m_key]
        _y_label = f"{m_key} [$mag \\cdot arcsec^{{-2}}$]"
    else:
        brightest_m_max = -2.5*np.log10(brightest_objects[m_key])
        _y_label = (f'$-2.5\\log(\\rm{{{m_key.replace('_', '\\_')}}})$ '
                    '[Arbitrary units]')

    logging.info(f"Selected {len(brightest_objects)} sources")

    fig, ax = make_bright_stars_selection_plot(
        mag_auto=cat[args.magauto_key],
        m_max=cat_m_max,
        fwhm=cat[args.fwhm_key],
        brightest_mag_auto=brightest_objects[args.magauto_key],
        brightest_m_max=brightest_m_max,
        mag_auto_sat_level=mag_auto_sat_level,
        mumax_hi_thresh=mumax_hi_thresh,
        sel_sigma=args.sel_sigma,
        scatt=scatt,
        lreg=lreg,
        pivot=pivot,
        idx_sorted=np.argsort(cat[args.fwhm_key]),
        scatter_marker_size=15,
        x_label=f"{args.magauto_key} [mag.]",
        y_label=_y_label,
        cbar_label=args.fwhm_key
    )

    fig.savefig(
        os.path.join(chk_img_out, "brightest_star_selection.png"),
        dpi=args.check_dpi
    )
    plt.close(fig)

    brightest_objects.write(
        os.path.join(args.out_dir, f"{cat_basename}_bright.fits"),
        overwrite=True
    )

    if args.dist_tol > 0:
        # Merge objects that are closer one to another less than a threshold
        logging.info("Merging close detections")
        sc = SkyCoord(
            brightest_objects[args.ra_key],
            brightest_objects[args.dec_key],
            unit="deg"
        )
        brightest_good_mask = np.ones_like(brightest_objects, dtype=bool)
        for j, obj in enumerate(tqdm(sc)):
            if brightest_good_mask[j] == False:
                continue

            close_mask = obj.separation(sc) <= (args.dist_tol * units.arcsec)
            idx = np.argmin(brightest_m_max + 100*~close_mask)
            close_mask[idx] = False
            brightest_good_mask[close_mask] = False

        brightest_objects = brightest_objects[brightest_good_mask]


    logging.info("Computing masks...")
    stars_sc = SkyCoord(brightest_objects[args.ra_key], brightest_objects[args.dec_key], unit='deg')
    mask_list = generate_masks(
        star_coords=stars_sc,
        star_mags=brightest_objects[args.magauto_key],
        angle=args.angle,
        spike_width=args.mask_width * units.arcsec,
        n_spikes=args.n_spikes,
        a=args.mask_a,
        b=args.mask_b,
        mag_ref=args.mask_magerf
    )

    my_regions = regions.Regions(mask_list)
    my_regions.write(
        os.path.join(chk_img_out, f"{cat_basename}_masks.reg"),
        format='ds9',
        overwrite=True
    )

    logging.info("Cleaning up input catalog...")
    coords = SkyCoord(
        orig_cat[args.ra_key], orig_cat[args.dec_key], unit='deg'
    )

    cleanup_mask = get_catalog_mask(coords, mask_list, img_wcs)

    try:
        ellipticity = 1 - orig_cat[args.bimage_key]/orig_cat[args.aimage_key]
        high_ellipticity = ellipticity > args.ellipticity_threshold
        cleanup_mask &= high_ellipticity
    except KeyError as exc:
        logging.error(f"Skipping ellipticity check: {str(exc)}")

    cleaned_catalog = orig_cat[~cleanup_mask]
    deleted_catalog = orig_cat[cleanup_mask]

    if not os.path.isdir(args.out_dir):
        os.mkdir(args.out_dir)

    cleaned_catalog.write(
        os.path.join(args.out_dir, f"{cat_basename}_clean.fits"),
        overwrite=True
    )

    deleted_catalog.write(
        os.path.join(args.out_dir, f"{cat_basename}_deleted.fits"),
        overwrite=True
    )

if __name__ == '__main__':
    main([
        '--verbose', '--check-images', '--debug',
        '--ra-key', 'RA', '--dec-key', 'DEC',
        '--magauto-thresh', '40',
        '--star-thresh', '1.5',
        '/home/daddona/projects/python-starspikes/test/sunburst-f814w_drc_sci.fits',
        '/home/daddona/projects/python-starspikes/test/sunburst-f814w_cols.cat',
        '9.914'
    ])