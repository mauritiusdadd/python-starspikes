import os
import sys
import logging
import argparse

import regions
from tqdm.auto import tqdm

import numpy as np

from astropy.coordinates import SkyCoord
from astropy import units
from astropy.table import Table
from astropy.wcs import WCS
from astropy.io import fits
from astropy.io.registry import IORegistryError

import matplotlib as mpl
from matplotlib import pyplot as plt

from starspikes.masking import distanceFromLine
from scipy.stats import linregress

def __argsHandler(options=None):
    parser = argparse.ArgumentParser(description='Process some integers.')

    parser.add_argument(
        'image', metavar='INPUT_IMG', type=str, default=None,
        help='The input image in fits format'
    )

    parser.add_argument(
        'input_catalog', metavar='INPUT_CAT', type=str, nargs=1,
        help='A catalog generated by sectractor using the same input image. '
        'Must contain the columns RA, DEC, MAG_AUTO, MU_MAX (or FLUX_MAX), '
        'and FWHM_IAMGE (of FWHM_WORLD).'
    )

    parser.add_argument(
        'angle', metavar='ANGLE', type=float,
        help='The angle of the primary spike.'
    )

    parser.add_argument(
        '--cat-hdu', metavar='CAT_HDU', type=int, default=1,
        help='The HDU containing the catalog to use (eg. for LDAC fits '
        'catalog generated by sextractor use %(metavar)s=2). If this argument '
        'is not specified, the image is loaded from the first HDU.'
    )

    parser.add_argument(
        '--check-images', default=False, action='store_true',
        help='Generate control images for the various operations performed.'
    )

    parser.add_argument(
        '--check-dir', metavar='CHK_FOLDER', type=str, default='checkimgs',
        nargs=1, help='Set the directory where check images and files are '
        'written. %(metavar)s should be a relative or an absolute path, if the'
        ' folder does not exists it will be automatically created. '
        'If this argument is not provided, the default value '
        '%(metavar)s=%(default)s is used.'
    )

    parser.add_argument(
        '--out-dir', metavar='OUT_FOLDER', type=str, default='.',
        help='Set the output directory where cleaned catalog are saved. '
        'If not specified, the current working directory is used.'
    )
    parser.add_argument(
        '--check-dpi', metavar='DPI', type=int, default=150,
        help='Set the DPI of the control images. if this parameter is not '
        'specified then the default value %(metavar)s=%(default)d is used.'
    )

    parser.add_argument(
        '--dist-tol', metavar='DIST_TOL_ARCSEC', type=float, default=0,
        help='Set the max distance, in arcsc, between two objects to be '
        'considered the same. If it is not specified, this parameter will have'
        ' a default value of %(metavar)s=%(default)d.'
    )

    parser.add_argument(
        '--star-thresh', type=float, default=None,
        help='Threshold for star selection. The greater it is, the more '
        'objects are considered as stars.'
    )

    parser.add_argument(
        '--sel-sigma', type=float, default=5,
        help='Number of std. dev.s to select stars from the fitted sequence.'
    )

    parser.add_argument(
        '--magauto-thresh', metavar='MAG_AUTO_THRESH', type=int, default=50,
        nargs=1, help='Ignore objects with MAG_AUTO > %(metavar)s. If not '
        'specified, the deafult value %(metavar)s=%(default)d is used.'
    )

    parser.add_argument(
        '--magauto-key', metavar='MAGAUTO_KEY', type=str, default='MAG_AUTO',
        nargs=1, help='Set the name of the column containing the automatic '
        'magnitudes. For catalogs generated by sextractor '
        '%(metavar)s=MAG_AUTO. If this argument is not specified the default '
        'value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--mumax-key', metavar='MU_MAX_KEY', type=str, default='MU_MAX',
        help='Set the name of the column containing the peak surface '
        'brightness above background. For catalogs generated by sextractor '
        '%(metavar)s=MU_MAX. If this argument is not specified the default '
        'value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--fluxmax-key', metavar='FLUX_MAX_KEY', type=str, default='FLUX_MAX',
        help='Set the name of the column containing the peak flux. This is '
        'used as fallback only if MU_MAX is not present in the catalog. '
        'For catalogs generated by sextractor %(metavar)s=FLUX_MAX. If this '
        'argument is not specified the default value %(metavar)s=%(default)s '
        'is used'
    )

    parser.add_argument(
        '--fwhm-key', metavar='FWHM_KEY', type=str,
        default='FWHM_IMAGE', help='Set the name of the column '
        'containing the FWHM of the objects. For catalogs generated by '
        'Sextractor %(metavar)s=FWHM_IMAGE or %(metavar)s=FWHM_WORLD.'
        'If this argument is not specified the default value '
        '%(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--ra-key', metavar='RA_KEY', type=str, default='RA',
        help='Set the name of the column containing the ra'
        'coordinates of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--dec-key', metavar='DEC_KEY', type=str, default='DEC',
        help='Set the name of the column containing the dec'
        'coordinates of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--aimage-key', metavar='A_IMAGE_KEY', type=str, default='A_IMAGE',
        help='Set the name of the column containing the major axis'
        'of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--bimage-key', metavar='B_IMAGE_KEY', type=str, default='B_IMAGE',
        help='Set the name of the column containing the y pixel'
        'coordinates of the objects. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--thetaimage-key', metavar='THETA_IMAGE_KEY', type=str,
        default='THETA_IMAGE', nargs=1, help='Set the name of the column '
        'containing the rotation angle of the major axis of the objects relative'
        'to the first image axis. For catalogs generated by sextractor '
        '%(metavar)s=%(default)s. If this argument is not specified the '
        'default value %(metavar)s=%(default)s is used'
    )

    parser.add_argument(
        '--delta-mag', metavar='DELTA_MAG', type=float,
        default=2, help='Number of magnitudes above the saturation level.'
    )

    parser.add_argument(
        '--ellipticity-threshold', metavar='TRESHOLD', type=float, default=0.2,
        help='Sets the ellipticity threshold below which objects that are '
        'maked as spurios spike detections will be removed.'
    )

    parser.add_argument(
        '--n-spikes', '-n', metavar='N', type=int, default=4,
        help='Set the number of spikes a star has. The default value is .'
        '%(metavar)s=%(default)s'
    )

    parser.add_argument(
        '--mask-width', metavar='WIDTH_ARCSEC', type=int, default=0.35,
        help='Set the width of the mask around the spikes. If this parameter '
        'is not specified the default value %(metavar)s=%(default)s is used.'
    )

    parser.add_argument(
        '--verbose', '-v', default=False, action='store_true',
        help='Increase the information outputed by the program.'
    )

    parser.add_argument(
        '--debug', default=False, action='store_true',
        help='Increase further the information outputed by the program.'
    )

    parser.add_argument(
        '--mask-a', type=float, default=5,
        help='Ref. spike size in arcsec. '
        'The default value %(metavar)s=%(default)s'
    )

    parser.add_argument(
        '--mask-b', type=float, default=0.01,
        help='Mask spike pseudo-flux scale factor.'
        'The default value %(metavar)s=%(default)s'
    )

    parser.add_argument(
        '--mask-magref', type=float, default=25,
        help='Ref. magnitude for spike size.'
        'The default value %(metavar)s=%(default)s'
    )

    return parser.parse_args(options)

def select_stars_from_cat(
    in_cat, fwhm_key='FWHM_IMAGE', pixel_scale_arcsec=None,
    fwhm_in_pixels='auto', selection_thresh=None
):
    if fwhm_in_pixels == 'auto':
        if 'image' in fwhm_key.lower():
            fwhm_in_pixels = True
        else:
            fwhm_in_pixels = False

    if pixel_scale_arcsec is not None:
        if fwhm_in_pixels:
            valid_fwhm_mask = in_cat[fwhm_key] > 2
        else:
            valid_fwhm_mask = in_cat[fwhm_key] > (pixel_scale_arcsec / 1800)
    else:
        if fwhm_in_pixels:
            valid_fwhm_mask = in_cat[fwhm_key] > 2
        else:
            valid_fwhm_mask = in_cat[fwhm_key] > 0

    cat = in_cat[valid_fwhm_mask]
    fwhm_min = np.nanmin(cat[fwhm_key])

    if selection_thresh is None:
        fwhm_thresh = np.median(cat[cat[fwhm_key] < fwhm_min * 3][fwhm_key])
    else:
        fwhm_thresh = fwhm_min * (1 + selection_thresh)
    if pixel_scale_arcsec is None:
        logging.info(f"FWHM: {fwhm_min:.2f} pixel")
    else:
        logging.info(f"FWHM: {fwhm_min * pixel_scale_arcsec:.2f}\"")
    return cat[cat[fwhm_key] <= fwhm_thresh]


def main(options=None):
    args = __argsHandler(options)

    font = {
        'size': 12
    }
    mpl.rc('font', **font)

    args = __argsHandler(options)

    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)


    console_handler = logging.StreamHandler()

    if args.verbose or args.debug:
        console_handler.setLevel(logging.INFO)
    else:
        console_handler.setLevel(logging.WARN)

    logger.addHandler(console_handler)

    cat_basename = os.path.basename(args.input_catalog[0])
    cat_basename = os.path.splitext(cat_basename)[0]

    if not os.path.isdir(args.check_dir):
        os.mkdir(args.check_dir)

    chk_img_out = os.path.join(
        args.check_dir,
        cat_basename
    )

    if not os.path.isdir(chk_img_out):
        os.mkdir(chk_img_out)

    logging.info(f"Loading input catalog {args.input_catalog[0]}...")
    try:
        orig_cat = Table.read(args.input_catalog[0], hdu=args.cat_hdu)
    except FileNotFoundError as exc:
        logging.error(f"Invalid catalog: {str(exc)}")
        sys.exit(1)
    except IORegistryError:
        try:
            orig_cat = Table.read(
                args.input_catalog[0],
                format='ascii',
                header_start=-1
            )
        except Exception as exc:
            logging.error(f"Invalid catalog: {str(exc)}")
            sys.exit(1)

    if args.magauto_key not in orig_cat.colnames:
        logging.error(f"Input catalog does not contain {args.magauto_key}")
        sys.exit(1)

    if (
        (args.mumax_key not in orig_cat.colnames) and
        (args.fluxmax_key not in orig_cat.colnames)
    ):
        logging.error(
            f"Input catalog does not contain neither {args.mumax_key} nor "
            f"{args.fluxmax_key}. At least one of the two is required!"
        )
        sys.exit(1)
    elif args.mumax_key in orig_cat.colnames:
        m_key = args.mumax_key
    else:
        m_key = args.fluxmax_key

    cat = orig_cat[orig_cat[args.magauto_key] < args.magauto_thresh]
    if m_key == args.mumax_key:
        cat_m_max = cat[m_key]
    else:
        cat_m_max = -2.5 * np.log10(cat[m_key])

    img_header = fits.getheader(args.image)

    logging.info(f"Loading WCS from image {args.image}")
    img_wcs = WCS(img_header)
    img_pixelscale = np.mean([
        x.to(units.arcsec).value for x in img_wcs.proj_plane_pixel_scales()
    ])
    logging.info(f"Mean pixel-scale: {img_pixelscale:.2f}\"")

    mag_thresh_mask = cat[args.magauto_key] <= args.magauto_thresh

    only_stars = select_stars_from_cat(
        cat[mag_thresh_mask],
        fwhm_key=args.fwhm_key,
        pixel_scale_arcsec=img_pixelscale,
        selection_thresh=args.star_thresh
    )

    mag_auto = only_stars[args.magauto_key]
    med_mag_auto = np.median(mag_auto)

    if m_key == args.mumax_key:
        m_max = only_stars[m_key]
        _y_label = f"{m_key} [$mag \\cdot arcsec^{{-2}}$]"
    else:
        m_max = -2.5*np.log10(only_stars[m_key])
        _y_label = (f'$-2.5\\log(\\rm{{{m_key.replace('_', '\\_')}}})$ '
                    '[Arbitrary units]')

    min_m_max = np.nanmin(m_max)
    lreg = linregress(mag_auto, m_max)

    res = m_max - (lreg.intercept + lreg.slope * mag_auto)
    scatt = 1.4826 * np.median(np.abs(res - np.median(res)))

    pivot = (
        med_mag_auto,
        lreg.intercept + lreg.slope * med_mag_auto
    )

    if args.check_images:
        fig, ax = plt.subplots(1, 1, figsize=(8, 8))

        scatter = ax.scatter(
            mag_auto,
            m_max,
            s=10,
            c=only_stars[args.fwhm_key],
            cmap='plasma',
            label='Candidate stars'
        )

        ax.axline(
            pivot,
            slope=lreg.slope,
            zorder=2,
            c='k',
            alpha=0.7,
            label='Fitted star sequence '
        )

        ax.set_xlabel('MAG_AUTO')
        ax.set_ylabel(_y_label)
        cbar = plt.colorbar(scatter)
        cbar.ax.set_ylabel(args.fwhm_key)

        plt.tight_layout()

        fig.savefig(
            os.path.join(chk_img_out, "fwhm_selection.png"),
            dpi=args.check_dpi
        )
    plt.close(fig)

    # Selecting points that are approximately  in the linear region
    # of the star sequence

    mag_auto_sat_level = (min_m_max - lreg.intercept) / lreg.slope
    mumax_hi_thresh = min_m_max + args.sel_sigma * scatt

    brightest_mask1 = cat_m_max <= (
                                        lreg.intercept +
                                        cat[args.magauto_key] * lreg.slope +
                                        args.sel_sigma * scatt
                                    )
    max_mag_level = mag_auto_sat_level + args.delta_mag
    brightest_mask1 &= cat[args.magauto_key] <= max_mag_level
    brightest_mask2 = cat_m_max <= mumax_hi_thresh

    selection_mask = brightest_mask1 | brightest_mask2

    brightest_objects = cat[selection_mask]

    # Making final plot
    if m_key == args.mumax_key:
        brightest_m_max = brightest_objects[m_key]
        _y_label = f"{m_key} [$mag \\cdot arcsec^{{-2}}$]"
    else:
        brightest_m_max = -2.5*np.log10(brightest_objects[m_key])
        _y_label = (f'$-2.5\\log(\\rm{{{m_key.replace('_', '\\_')}}})$ '
                    '[Arbitrary units]')

    logging.info(f"Selected {len(brightest_objects)} sources")

    idx_sorted = np.argsort(cat[args.fwhm_key])
    scatter_marker_size = 15
    fig, ax = plt.subplots(1, 1, figsize=(10, 8))
    ax.set_facecolor('#EAEAF2')
    ax.grid(
        visible=None, which='major', axis='both', color='white', alpha=1.0
    )
    ax.set_axisbelow(True)
    scatter = ax.scatter(
        cat[args.magauto_key][idx_sorted],
        cat_m_max[idx_sorted],
        c=cat[args.fwhm_key][idx_sorted],
        cmap='plasma',
        s=scatter_marker_size,
        alpha=1.0,
        label='Objects'
    )

    _ = ax.scatter(
        brightest_objects[args.magauto_key],
        brightest_m_max,
        facecolor='none',
        edgecolor='red',
        s=scatter_marker_size,
        lw=1.5,
        alpha=0.5,
        label='Selected objects'
    )

    plt.margins(0.05, 0.05)
    fit_lw = 1.5

    ax.set_xlabel(fr"{args.magauto_key} [$mag$]")
    ax.set_ylabel(fr"{_y_label}")

    cbar = fig.colorbar(
        scatter,
        location='right',
        anchor=(0, 0.3)
    )

    cbar.ax.get_yaxis().labelpad = 15
    cbar.ax.set_ylabel(f"{args.fwhm_key}", rotation=270)

    plt.tight_layout()

    x_min = ax.get_xlim()[0]
    x_max = ax.get_xlim()[1]
    y_min = ax.get_ylim()[0]

    # Plotting star sequence fit
    ax.axline(
        pivot,
        slope=lreg.slope,
        zorder=2,
        color='magenta',
        ls='-',
        lw=fit_lw,
        alpha=0.5,
        label='Fitted star sequence '
    )

    ax.axvline(
        mag_auto_sat_level,
        color='red',
        ls='--',
        lw=fit_lw,
        label=f'{args.magauto_key} sat. level',
        alpha=0.3
    )

    # Plot brightest and saturated objects selection region
    sel_boundary_lw = 1.5
    ax.plot(
        (x_min, mag_auto_sat_level, x_max),
        (
            mumax_hi_thresh,
            mumax_hi_thresh,
            lreg.intercept + x_max*lreg.slope + args.sel_sigma * scatt
        ),
        color='red',
        ls='--',
        lw=sel_boundary_lw
    )

    _ = ax.annotate(
        '$x_{sat}$',
        xy=(mag_auto_sat_level, 0),
        xytext=(mag_auto_sat_level, 0.025),
        xycoords=ax.get_xaxis_transform(),
        textcoords=ax.get_xaxis_transform(),
        fontsize=16,
        arrowprops=dict(
            facecolor='black',
            arrowstyle='-'
        )
    )

    _ = ax.legend()

    fig.savefig(
        os.path.join(chk_img_out, "brightest_star_selection.png"),
        dpi=args.check_dpi
    )
    plt.close(fig)

    brightest_objects.write(
        os.path.join(args.out_dir, f"{cat_basename}_bright.fits"),
        overwrite=True
    )

    if args.dist_tol > 0:
        # Merge objects that are closer one to another less than a threshold
        logging.info("Merging close detections")
        sc = SkyCoord(
            brightest_objects[args.ra_key],
            brightest_objects[args.dec_key],
            unit="deg"
        )
        brightest_good_mask = np.ones_like(brightest_objects, dtype=bool)
        for j, obj in enumerate(tqdm(sc)):
            if brightest_good_mask[j] == False:
                continue

            close_mask = obj.separation(sc) <= (args.dist_tol * units.arcsec)
            idx = np.argmin(brightest_m_max + 100*~close_mask)
            close_mask[idx] = False
            brightest_good_mask[close_mask] = False

        brightest_objects = brightest_objects[brightest_good_mask]

    mask_list = []
    logging.info("Computing masks...")
    spike_width = args.mask_width * units.arcsec
    for star in tqdm(brightest_objects):
        len_spike = (
            args.mask_a + args.mask_b * (
                10**((args.mask_magref - star[args.magauto_key])/2.5)
            )
        ) * units.arcsec

        center_sc = SkyCoord(star[args.ra_key], star[args.dec_key], unit='deg')
        for k in range(args.n_spikes):
            spike = regions.RectangleSkyRegion(
                center=center_sc,
                width=spike_width,
                height=len_spike,
                angle=(args.angle + (k * 360 / args.n_spikes) ) * units.deg
            )
            mask_list.append(spike)
        circle = regions.CircleSkyRegion(
            center=center_sc,
            radius=2*units.arcsec
        )

        mask_list.append(circle)

    my_regions = regions.Regions(mask_list)
    my_regions.write(
        os.path.join(chk_img_out, f"{cat_basename}_masks.reg"),
        format='ds9',
        overwrite=True
    )

    coords = SkyCoord(
        orig_cat[args.ra_key], orig_cat[args.dec_key], unit='deg'
    )

    cleanup_mask = None
    logging.info("Cleaning up input catalog...")

    for region in tqdm(mask_list):
        if cleanup_mask is None:
            cleanup_mask = region.contains(coords, img_wcs)
        else:
            cleanup_mask |= region.contains(coords, img_wcs)

    try:
        ellipticity = 1 - orig_cat[args.bimage_key]/orig_cat[args.aimage_key]
        high_ellipticity = ellipticity > args.ellipticity_threshold
        cleanup_mask &= high_ellipticity
    except KeyError as exc:
        logging.error(f"Skipping ellipticity check: {str(exc)}")

    cleaned_catalog = orig_cat[~cleanup_mask]
    deleted_catalog = orig_cat[cleanup_mask]

    if not os.path.isdir(args.out_dir):
        os.mkdir(args.out_dir)

    cleaned_catalog.write(
        os.path.join(args.out_dir, f"{cat_basename}_clean.fits"),
        overwrite=True
    )

    deleted_catalog.write(
        os.path.join(args.out_dir, f"{cat_basename}_deleted.fits"),
        overwrite=True
    )

if __name__ == '__main__':
    main([
        '--verbose', '--check-images', '--debug',
        '--ra-key', 'RA', '--dec-key', 'DEC',
        '--magauto-thresh', '40',
        '--star-thresh', '1.5',
        '/home/daddona/projects/python-starspikes/test/sunburst-f814w_drc_sci.fits',
        '/home/daddona/projects/python-starspikes/test/sunburst-f814w_cols.cat',
        '9.914'
    ])